#!/usr/bin/env perl
use v5.26;
use strict;
use warnings;
use feature 'unicode_strings';

# This is like pod2github or pod2markdown, but takes a list of filename(s)
# as arguments and outputs markdown documents in the right location(s)
# using the right arguments for Conch.

# Usage:
# misc/pod2githubpages <filename> [filename ... ]

use Pod::Markdown::Github;
use Class::Method::Modifiers 'around';
use Path::Tiny;
use JSON::MaybeXS;
use YAML::XS;

my %opts = (
    output_encoding => 'UTF-8',
    local_module_re => qr/Conch/,
    local_module_url_prefix => '../modules/',
);

around 'Pod::Markdown::format_perldoc_url' => sub {
    my $orig = shift;
    my $self = shift;

    my $url = $self->$orig(@_);
    if ($url =~ /^\Q${\ $self->perldoc_url_prefix }\E/ and -x "bin/$'") {
        $url = '../scripts/'.$';
    }

    if ($url =~ /#/) {
        my ($base, $fragment) = split(/#/, $url);
        my $new_fragment = lc($_[1])    # lower-case
            =~ s/[^\w -]//gr            # strip verything but word chars, space and -
            =~ tr/ /-/r;                # spaces become -
        $url = $base.'#'.$new_fragment;
    }

    return $url;
};

around 'Pod::Markdown::end_F' => sub {
    my $orig = shift;
    my $self = shift;

    return $self->$orig(@_) if $self->_last_string !~ m{^[^.]+\.yaml};

    $self->_private->{no_escape}--; # as done in original end_F

    my $text = $self->_pop_stack_text =~ s{^([^.]+)\.yaml}{$1.json}r;
    $self->_save('['.$text.']('.'../json-schema/'.$text.')');
};

around 'Pod::Markdown::start_for' => sub {
    my $orig = shift;
    my $self = shift;
    $self->$orig(@_);

    if ($_[0]->{target_matching} eq 'eval') {
        $self->_stack_state->{for_eval} = 1;
        $self->_private->{no_escape} = 1;
        $self->_private->{encode_amp} = 0;
        $self->_private->{encode_lt} = 0;
    }
};

around 'Pod::Markdown::end_for' => sub {
    my $orig = shift;
    my $self = shift;

    return $self->$orig(@_) if not $self->_stack_state->{for_eval};

    my $text = $self->_pop_stack_text;
    my $newtext = eval($text) || $@;

    # pass resulting pod through pod -> markdown conversion
    $newtext = "=pod\n\n". $newtext;
    open my $outfh, '>', \my $outstr;
    open my $infh, '<', \$newtext;
    convert($infh, $outfh);
    $self->_save_block($self->_chomp_all($outstr));
};

around 'Pod::Markdown::Github::syntax' => sub {
    my $orig = shift;
    my $self = shift;
    my $lang = $self->$orig(@_);
    # the heuristic is a bit too eager -- do not assume perl if $ is nowhere to be seen
    $lang eq 'perl' && $_[0] !~ /\$/ ? '' : $lang;
};

my (@module_files, @bin_files, @json_schema_files);

foreach my $dir (qw(modules scripts json-schema)) {
    mkdir 'docs/'.$dir if not -d 'docs/'.$dir;
    path('docs', $dir, 'README')->spew_utf8(<<README);
This directory and its contents are automatically generated by misc/pod2githubpages.
DO NOT manually edit these files, but rather the sources they were generated from.
README
}

my @all_files = @ARGV;
foreach my $infile (@all_files) {
    # convert:                          lib/Conch/Time.pm            and  bin/conch-db
    # to:                               docs/modules/Conch::Time.md  and  docs/scripts/conch-db.md
    # containing pod links like:        L<Conch::Time>               and  L<conch-db>
    # become relative URLs like:        ../modules/Conch::Time       and  ../scripts/conch-db
    # that turn into the absolute urls: https://joyent.github.io/conch/modules/Conch::Time
    # ...and:                           http://localhost:4000/modules/Conch::Time


    my $outfile = $infile;
    if ($outfile =~ s{^lib/}{}) {
        $outfile =~ s{/}{::}g;
        $outfile =~ s/\.pm$/\.md/;
        push @module_files, $outfile;
        $outfile = 'docs/modules/'.$outfile;
    }
    elsif ($outfile =~ s{^bin/}{}) {
        $outfile =~ s/$/\.md/;
        push @bin_files, $outfile;
        $outfile = 'docs/scripts/'.$outfile;
    }
    else { next }

    open(my $in_fh, '<', $infile) or die "Failed to open '$infile': $!";
    open(my $out_buffer, '>', \my $markdown) or die "Failed to open scalarref: $!";

    # Undo any PERL_UNICODE effects.
    # Pod::Simple expects to receive bytes, and we're going to return bytes.
    binmode($_, ':bytes') for ($in_fh, $out_buffer);

    convert($in_fh, $out_buffer);

    $markdown =~ s/^(#+)/$1#/mg;
    my $url = 'https://github.com/joyent/conch/blob/master/'.$infile;
    $markdown =~ s{## NAME\n\n(.+)$}{# $1\n\n## SOURCE\n\n[$url]($url)}m;

    path($outfile)->spew($markdown);
}

my $json_encoder = JSON()->new->pretty->indent_length(2)->canonical(1);
foreach my $filename (grep m{^json-schema/[^.]+\.yaml$}, @all_files) {
    my $data = YAML::XS::LoadFile($filename);
    my $base = path($filename)->basename('.yaml');
    my ($type) = $filename =~ m{^json-schema/([^.]+)\.yaml$};
    $data->{'$comment'} = 'NOTE: This file is for human reference ONLY. For programmatic use, use the GET \'/schema/'.$type.'/$schema_name\' endpoints, or within conch itself, json-schema/'.$type.'.yaml.' . ($data->{'$comment'} ? ("\n".$data->{'$comment'}) : '');
    my $json_content = $json_encoder->encode($data);

    my @lines = split("\n", $json_content);
    s{(?<!json-schema/$type)\.yaml}{\.json} foreach @lines;

    path('docs/json-schema/'.$base.'.json')->spew_utf8(join("\n", @lines), "\n");
    push @json_schema_files, $base.'.json';
}


my $footer = <<'FOOTER';

[Back to main index](../)

# Copyright / License

Copyright Joyent, Inc.

This Source Code Form is subject to the terms of the Mozilla Public License,
v.2.0. If a copy of the MPL was not distributed with this file, you can
obtain one at <http://mozilla.org/MPL/2.0/>.
FOOTER

{
    open my $fh, '>', 'docs/modules/index.md'
        or die "cannot open docs/modules/index.md for writing: $!";

    print $fh "# Module documentation\n\n";

    foreach my $filename (sort @module_files) {
        my $module = $filename =~ s/.md$//r;
        print $fh '* [', $module, '](../modules/', $module, ")\n";
    }

    print $fh $footer;
    close $fh;
}

{
    open my $fh, '>', 'docs/scripts/index.md'
        or die "cannot open docs/scripts/index.md for writing: $!";

    print $fh "# Executable documentation (in `bin/`)\n\n";

    foreach my $filename (sort @bin_files) {
        my $exe = $filename =~ s/.md$//r;
        print $fh '* [', $exe, '](../scripts/', $exe, ")\n";
    }

    print $fh $footer;
    close $fh;
}

{
    open my $fh, '>', 'docs/json-schema/index.md'
        or die "cannot open docs/json-schema/index.md for writing: $!";

    print $fh "# JSON Schema documentation (in `json-schema/`)\n\n";

    foreach my $filename (sort @json_schema_files) {
        my $sch = $filename =~ s/.json$//r;
        print $fh '* [', $sch, '](../json-schema/', $filename, ")\n";
    }

    print $fh $footer;
    close $fh;
}

sub convert {
    my ($in_fh, $out_fh) = @_;
    my $parser = Pod::Markdown::Github->new(%opts);

    $parser->accept_targets(qw(markdown html eval));

    $parser->output_fh($out_fh);
    $parser->parse_file($in_fh);
}
